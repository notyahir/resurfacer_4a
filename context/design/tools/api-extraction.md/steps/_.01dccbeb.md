---
timestamp: 'Mon Nov 03 2025 18:13:25 GMT-0500 (Eastern Standard Time)'
parent: '[[../20251103_181325.11388c83.md]]'
content_id: 01dccbeb0255947e0c00cb55959cd2af3ac7562a80ba75c600aead873956f460
---

# App API

## `PlatformLink`

Provides authenticated access to streaming platforms, managing tokens and capabilities securely so other concepts don't handle credentials.

### Actions

* **`link`**
  * Creates a new link to a streaming platform for a given user.
  * **Parameters**: `{ userId: User, platform: string }`
  * **Returns**: `Promise<{ linkId: string } | { error: string }>`

* **`refresh`**
  * Refreshes the access token for an existing link.
  * **Parameters**: `{ linkId: string }`
  * **Returns**: `Promise<{ newExpiration: number } | { error: string }>`

* **`revoke`**
  * Revokes a user's link to a platform, deleting all associated data.
  * **Parameters**: `{ linkId: string }`
  * **Returns**: `Promise<{ removed: boolean } | { error: string }>`

* **`can`**
  * Checks if a link is active and possesses a specific capability.
  * **Parameters**: `{ linkId: string, capability: string }`
  * **Returns**: `Promise<{ ok: boolean }>`

* **`listLinks`**
  * Lists all platform links associated with a user.
  * **Parameters**: `{ userId: User }`
  * **Returns**: `Promise<{ links: Array<{ linkId: string, platform: string, tokenExpiration: number }> } | { error: string }>`

* **`syncLibrary`**
  * Accepts a full library payload (tracks, likes, plays, playlists) and syncs it into the `LibraryCache` concept for the user associated with the link.
  * **Parameters**: `{ linkId: string, payload: { userId: User, tracks: Array<{...}>, likes: Array<{...}>, plays: Array<{...}>, playlists: Array<{...}> } }`
  * **Returns**: `Promise<{ synced: boolean } | { error: string }>`

* **`bootstrapTrackScoring`**
  * A convenience method to ingest stats from `LibraryCache` into `TrackScoring` and prime the user's scores.
  * **Parameters**: `{ userId: User, size?: number }`
  * **Returns**: `Promise<{ ingested: number, ensuredWeights: boolean, previewCount: number, source: "scores" | "bootstrap" | "empty" } | { error: string }>`

***

## `LibraryCache`

Maintains a local, queryable snapshot of a userâ€™s tracks, likes, plays, and playlists for analysis and tooling.

### Actions

* **`ingest` / `sync`**
  * Performs a full replacement sync for a user's library data, updating track metadata and replacing likes, plays, and playlists. `ingest` is an alias for `sync`.
  * **Parameters**: `{ userId: User, tracks: TrackData[], likes: LikeData[], plays: PlayData[], playlists: PlaylistData[] }`
  * **Returns**: `Promise<{}> | { error: string }>`

### Queries

* **`_getLiked`**
  * Returns a list of track IDs for a user's liked tracks, sorted by most recently added.
  * **Parameters**: `{ userId: User }`
  * **Returns**: `Promise<{ trackIds: string[] } | { error: string }>`

* **`_getPlaylist`**
  * Returns an ordered list of track IDs for a given playlist.
  * **Parameters**: `{ playlistId: string }`
  * **Returns**: `Promise<{ entries: string[] } | { error: string }>`

***

## `TrackScoring`

Computes a "staleness" score for each track in a user's library and manages user-driven boosts or snoozes to influence which tracks get resurfaced.

### Actions

* **`updateWeights`**
  * Updates the scoring weights used to calculate staleness for a given user.
  * **Parameters**: `{ userId: User, lastPlayedW: number, likedWhenW: number, timesSkippedW: number }`
  * **Returns**: `Promise<{}> | { error: string }>`

* **`updateStats`**
  * Updates the raw playback statistics for a user-track pair.
  * **Parameters**: `{ userId: User, trackId: string, lastPlayedAt: number, likedAt: number, timesSkipped: number }`
  * **Returns**: `Promise<{}> | { error: string }>`

* **`score`**
  * Computes, stores, and returns a staleness score (0-100) for a given track based on the user's weights and the track's stats.
  * **Parameters**: `{ userId: User, trackId: string }`
  * **Returns**: `Promise<{ score: number } | { error: string }>`

* **`preview`**
  * Returns a list of tracks for a user, sorted by their staleness score in descending order.
  * **Parameters**: `{ userId: User, size?: number }`
  * **Returns**: `Promise<{ trackIds: string[], tracks: Array<{trackId: string, score: number, lastPlayedAt?: number}>, source: string } | { error: string }>`

* **`keep`**
  * Increases a track's boost, making it more likely to be resurfaced in the future.
  * **Parameters**: `{ userId: User, trackId: string }`
  * **Returns**: `Promise<{}> | { error: string }>`

* **`snooze`**
  * Snoozes a track for a user, preventing it from being resurfaced for a specified period.
  * **Parameters**: `{ userId: User, trackId: string, until?: number }`
  * **Returns**: `Promise<{}> | { error: string }>`

* **`ingestFromLibraryCache`**
  * Populates initial track stats for a user by ingesting data from `LibraryCache`.
  * **Parameters**: `{ userId: User }`
  * **Returns**: `Promise<{ ingested: number, ensuredWeights: boolean } | { error: string }>`

***

## `SwipeSessions`

Runs deterministic "memory card" style swipe sessions over a queue of tracks, recording user decisions locally without immediate side effects.

### Actions

* **`start`**
  * Creates and starts a new swipe session for a user with a given queue of tracks.
  * **Parameters**: `{ userId: User, queueTracks: string[], size?: number }`
  * **Returns**: `Promise<{ sessionId: string } | { error: string }>`

* **`next`**
  * Retrieves the next track in the session's queue and advances the cursor.
  * **Parameters**: `{ sessionId: string }`
  * **Returns**: `Promise<{ trackId: string } | { error: string }>` (returns `trackId: "-1"` when the queue is empty).

* **`decideKeep`**
  * Records a 'keep' decision for the current track in a session.
  * **Parameters**: `{ sessionId: string, trackId: string }`
  * **Returns**: `Promise<{ decisionId: string } | { error: string }>`

* **`decideSnooze`**
  * Records a 'snooze' decision for the current track in a session.
  * **Parameters**: `{ sessionId: string, trackId: string, untilAt?: number }`
  * **Returns**: `Promise<{ decisionId: string } | { error: string }>`

* **`decideAddToPlaylist`**
  * Records a decision to add the current track to an existing playlist.
  * **Parameters**: `{ sessionId: string, trackId: string, playlistId: string }`
  * **Returns**: `Promise<{ decisionId: string } | { error: string }>`

* **`decideCreatePlaylist`**
  * Records a decision to create a new playlist with the current track.
  * **Parameters**: `{ sessionId: string, trackId: string, playlistTitle: string }`
  * **Returns**: `Promise<{ decisionId: string } | { error: string }>`

* **`end`**
  * Ends and deletes a session.
  * **Parameters**: `{ sessionId: string }`
  * **Returns**: `Promise<{ ended: boolean }>`

***

## `PlaylistHealth`

Analyzes a snapshot of a playlist to detect issues such as duplicate tracks, unavailable tracks, and audio feature outliers.

### Actions

* **`snapshot`**
  * Creates and stores a snapshot of a playlist's current track list.
  * **Parameters**: `{ playlistId: string, userId: User, trackIds: string[] }`
  * **Returns**: `Promise<{ snapshotId: string } | { error: string }>`

* **`analyze`**
  * Analyzes a given snapshot to find potential issues and generates a health report.
  * **Parameters**: `{ playlistId: string, snapshotId: string }`
  * **Returns**: `Promise<{ reportId: string } | { error: string }>`

* **`getReport`**
  * Retrieves the findings from a previously generated playlist health report.
  * **Parameters**: `{ reportId: string }`
  * **Returns**: `Promise<{ playlistId: string, snapshotId: string, findings: Array<{ idx: number, trackId: string, kind: string }> } | { error: string }>`
